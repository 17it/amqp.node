{"name":"amqplib","tagline":"AMQP 0-9-1 library and client for Node.JS","body":"# AMQP 0-9-1 library and client for Node.JS\r\n\r\n`amqplib` implements the machinery needed to make clients for AMQP\r\n0-9-1, and includes such a client. Why phrase it that way around?\r\nBecause AMQP is complicated enough that there are a few different ways\r\nof presenting it in API form (e.g., [node-amqp][] deals with\r\nexchanges and queues as first-class objects, while hiding channels;\r\n[rabbit.js][] deprecates exchanges and queues in favour of\r\nrouting patterns).\r\n\r\nAMQP often seems to be designed to confound client developers; it is\r\nnot very cleanly layered and there are consequences to molding it this\r\nway or that in search of a usable API. In `amqplib` I have tried to\r\nimplement only the necessary machinery of AMQP, in layers as best I\r\ncan, without prejudice to any particular client API.\r\n\r\n## Channel API overview\r\n\r\n```javascript\r\nvar q = 'tasks';\r\n\r\n// Publisher\r\nvar open = require('amqplib').connect('amqp://localhost');\r\nopen.then(function(conn) {\r\n  var ok = conn.createChannel();\r\n  ok = ok.then(function(ch) {\r\n    ch.assertQueue(q);\r\n    ch.sendToQueue(q, new Buffer('something to do'));\r\n  });\r\n  return ok;\r\n}).then(null, console.warn);\r\n\r\n// Consumer\r\nopen.then(function(conn) {\r\n  var ok = conn.createChannel();\r\n  ok = ok.then(function(ch) {\r\n    ch.assertQueue(q);\r\n    ch.consume(q, function(msg) {\r\n      console.log(msg.content.toString());\r\n      ch.ack(msg);\r\n    });\r\n  });\r\n  return ok;\r\n}).then(null, console.warn);\r\n```\r\n\r\nThe client API included is channel-oriented. This represents the\r\nprotocol fairly directly, as connections and channels (something like\r\n'sessions'). Most of the operations in the API are accessed by\r\ncreating a channel and calling methods; exchanges and queues are only\r\nrepresented insofar as they are named (with strings) in these\r\noperations.\r\n\r\nAlmost all operations are asynchronous RPCs; these methods on\r\n`Channel` return promises which can be composed in all the usual\r\nways. Some operations (e.g., `#ack`) elicit no response from the\r\nserver, and don't return a promise.\r\n\r\nIn general I have made arguments that are mandatory in the protocol\r\ninto method arguments in the API, and coalesced optional arguments,\r\nproperties, and RabbitMQ extensions into a single `options` argument\r\nwhich can be ommitted altogether.\r\n\r\nThe [reference](doc/channel_api.html) has full details.\r\n\r\n## Library overview\r\n\r\nTo be able to get anywhere at all, an AMQP library needs to be able to\r\n\r\n * parse and serialise frames\r\n * maintain connection and channel state\r\n * implement the opening and closing handshakes\r\n\r\nIn `amqplib`, parsing and serialising are dealt with in the modules\r\n\r\n * `codec` procedures for parsing and serialising values;\r\n *  `defs` generated code for encoding and decoding protocol methods;\r\n    and,\r\n * `frames` for turning a byte streams into decoded frames and\r\n   vice-versa.\r\n\r\nConnection state is maintained in a `Connection` object (module\r\n`connection`) and channel state in a `Channel` (module `channel`);\r\nthese two modules also implement the opening and closing handshakes.\r\n\r\nThe interfaces among these modules is small and mostly mediated with\r\nprimitive values; e.g., strings and numbers. A few points of interface\r\nrequire callbacks in the form of duck-typed objects (e.g., an object\r\nwith an `#accept` method).\r\n\r\n\r\n[rabbit.js]: https://github.com/squaremo/rabbit.js\r\n[node-amqp]: https://github.com/postwait/node-amqp\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}